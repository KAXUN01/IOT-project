"""
ML Security Engine for IoT DDoS Attack Detection
Real-time network traffic analysis using pre-trained ML models
"""

import numpy as np
import pandas as pd
import tensorflow as tf
from tensorflow import keras
import json
import time
from datetime import datetime, timedelta
from collections import deque
import threading
import logging
import os
import ipaddress

# Module-level constants for health checks
HEALTH_CHECK_INTERVAL = 60  # seconds
MAX_RELOAD_ATTEMPTS = 3
INIT_TIMEOUT = 30  # seconds

# Constants for IP blocking
BLOCK_DURATION = 300  # 5 minutes default block duration
ATTACK_THRESHOLD = 0.8  # Confidence threshold for blocking

# Global ML engine instance placeholder (set by controller)
ml_engine = None

class MLSecurityEngine:
    def __init__(self, model_path="models/ddos_model_retrained.keras"):
        """
        Initialize ML Security Engine with pre-trained DDoS detection model
        """
        self.model = None
        self.model_path = model_path
        self.is_loaded = False
        self.initialization_time = time.time()
        self.last_health_check = time.time()
        self.reload_attempts = 0
        self.health_check_thread = None
        self.is_running = True
        self.attack_detections = deque(maxlen=1000)  # Store last 1000 detections
        self.blocked_ips = {}  # Dictionary to track blocked IPs and their block duration
        self.network_stats = {
            'total_packets': 0,
            'attack_packets': 0,
            'normal_packets': 0,
            'attack_rate': 0.0,
            'detection_accuracy': 0.0,
            'uptime': 0,
            'last_health_check': None,
            'model_status': 'initializing'
        }
        self.real_time_features = deque(maxlen=100)
        self.attack_types = {
            0: 'Normal',
            1: 'DDoS Attack',
            2: 'Botnet Attack',
            3: 'Flood Attack'
        }
        
        # Initialize logging
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(__name__)
        
        # Load the model
        if not self.load_model():
            self.logger.error("âŒ Initial model load failed")
            return
            
        # Start health check thread
        self.start_health_checks()

    def detect_attack(self, traffic_data, source_ip, target_ip):
        """
        Detect attacks with enhanced information
        """
        try:
            prediction = self.model.predict(np.array([traffic_data]))
            confidence = float(np.max(prediction[0]) * 100)
            attack_type = self.attack_types[np.argmax(prediction[0])]
            
            # Calculate packets per second from traffic data
            packets_per_sec = sum(traffic_data[:5])  # Assuming first 5 features are packet-related
            
            # Check if IP is already blocked
            is_blocked = source_ip in self.blocked_ips
            block_duration = None
            
            # Determine if we should block this IP
            if attack_type != 'Normal' and confidence > ATTACK_THRESHOLD * 100:
                if not is_blocked:
                    self.block_ip(source_ip)
                    is_blocked = True
                block_duration = self.get_block_duration(source_ip)
            
            detection_info = {
                'timestamp': datetime.now().strftime('%I:%M:%S %p'),
                'type': attack_type,
                'confidence': round(confidence, 2),
                'sourceIp': source_ip,
                'targetIp': target_ip,
                'attackType': attack_type if attack_type != 'Normal' else None,
                'packetsPerSec': round(packets_per_sec, 2),
                'isBlocked': is_blocked,
                'blockDuration': block_duration
            }
            
            self.attack_detections.appendleft(detection_info)
            return detection_info
            
        except Exception as e:
            self.logger.error(f"Error in attack detection: {e}")
            return None

    def block_ip(self, ip_address):
        """
        Block an IP address for a specified duration
        """
        if ip_address not in self.blocked_ips:
            block_end_time = datetime.now() + timedelta(seconds=BLOCK_DURATION)
            self.blocked_ips[ip_address] = block_end_time
            self.logger.info(f"ðŸš« Blocked IP {ip_address} until {block_end_time}")
            return True
        return False

    def get_block_duration(self, ip_address):
        """
        Get remaining block duration for an IP
        """
        if ip_address in self.blocked_ips:
            remaining = self.blocked_ips[ip_address] - datetime.now()
            if remaining.total_seconds() > 0:
                return f"{int(remaining.total_seconds())}s"
            else:
                del self.blocked_ips[ip_address]
        return None

    def cleanup_blocked_ips(self):
        """
        Clean up expired IP blocks
        """
        current_time = datetime.now()
        expired = [ip for ip, end_time in self.blocked_ips.items() if end_time <= current_time]
        for ip in expired:
            del self.blocked_ips[ip]
            self.logger.info(f"âœ… Unblocked IP {ip}")

    def start_health_checks(self):
        """Start periodic health checks"""
        def health_check_loop():
            while self.is_running:
                try:
                    self.check_health()
                    self.cleanup_blocked_ips()  # Add IP cleanup to health checks
                    time.sleep(HEALTH_CHECK_INTERVAL)
                except Exception as e:
                    self.logger.error(f"Health check error: {e}")
                    time.sleep(5)  # Wait before retry
        
        self.health_check_thread = threading.Thread(
            target=health_check_loop,
            name="ML_HealthCheck",
            daemon=True
        )
        self.health_check_thread.start()

    def check_health(self) -> bool:
        """
        Check ML engine health and reload if necessary
        Returns True if healthy, False otherwise
        """
        try:
            self.last_health_check = time.time()
            self.network_stats['last_health_check'] = datetime.now().isoformat()
            
            # Update uptime
            self.network_stats['uptime'] = time.time() - self.initialization_time
            
            if not self.is_loaded or self.model is None:
                if self.reload_attempts < MAX_RELOAD_ATTEMPTS:
                    self.logger.warning("âš ï¸ Model not loaded, attempting reload...")
                    return self.load_model()
                else:
                    self.logger.error("âŒ Max reload attempts reached")
                    return False
                    
            # Test model with dummy data
            try:
                dummy_data = np.zeros((1, self.model.input_shape[1]))
                _ = self.model.predict(dummy_data)
                self.network_stats['model_status'] = 'healthy'
                return True
            except Exception as e:
                self.logger.error(f"Model health check failed: {e}")
                self.network_stats['model_status'] = 'error'
                return False
                
        except Exception as e:
            self.logger.error(f"Health check failed: {e}")
            return False