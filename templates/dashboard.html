<!DOCTYPE html>
<html>
<head>
    <title>IoT Security Framework - ML-Powered Dashboard</title>
    <style>
        body {
            margin: 0;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e1e2f 0%, #2a2a4a 100%);
            color: #e0e0e0;
            padding: 20px;
        }
        h1, h2 {
            color: #00d4ff;
            text-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
            margin-bottom: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        .section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(5px);
        }
        .section h2 {
            margin-top: 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            background: rgba(255, 255, 255, 0.1);
        }
        th, td {
            padding: 12px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        th {
            background: linear-gradient(45deg, #00d4ff, #007bff);
            color: #fff;
        }
        td {
            background: rgba(255, 255, 255, 0.05);
        }
        .authorized {
            background: rgba(0, 255, 144, 0.2);
            color: #00ff90;
        }
        .unauthorized {
            background: rgba(255, 99, 71, 0.2);
            color: #ff6347;
        }
        button {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background: linear-gradient(45deg, #00d4ff, #007bff);
            color: #fff;
            transition: transform 0.1s, box-shadow 0.2s;
        }
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
        }
        #network {
            width: 100%;
            height: 500px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
        }
        .legend {
            margin: 10px 0;
            font-size: 14px;
        }
        .legend span {
            display: inline-block;
            width: 20px;
            height: 20px;
            vertical-align: middle;
            margin-right: 5px;
        }
        .graph-container {
            text-align: center;
        }
        .graph-container img {
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        .packet-counter {
            text-align: center;
            font-size: 24px;
            margin: 20px 0;
            color: #00ff90;
            text-shadow: 0 0 10px rgba(0, 255, 144, 0.5);
        }
        .health-metrics, .policy-controls, .sdn-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        .metric-card, .policy-card, .sdn-metric {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        .metric-card h3, .policy-card h3, .sdn-metric h3 {
            margin: 0 0 10px;
            color: #00d4ff;
        }
        .metric-bar {
            height: 10px;
            background: #444;
            border-radius: 5px;
            overflow: hidden;
        }
        .metric-bar div {
            height: 100%;
            background: linear-gradient(90deg, #00d4ff, #007bff);
            transition: width 0.5s ease;
        }
        .policy-logs {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 5px;
        }
        .policy-logs p {
            margin: 5px 0;
            font-size: 14px;
        }
        .ml-section {
            background: linear-gradient(135deg, #2d1b69 0%, #11998e 100%);
            border: 2px solid #00d4ff;
        }
        .ml-metric {
            display: inline-block;
            margin: 10px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            text-align: center;
            min-width: 120px;
        }
        .ml-metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #00d4ff;
        }
        .ml-metric-label {
            font-size: 12px;
            color: #ccc;
            margin-top: 5px;
        }
        .attack-alert {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            border: 2px solid #ff3838;
            animation: alertPulse 2s infinite;
        }
        @keyframes alertPulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 56, 56, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 56, 56, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 56, 56, 0); }
        }
    </style>
    <script src="static\vis-network.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>SDN IoT Advanced Dashboard</h1>

        <div class="section">
            <h2>Device Overview</h2>
            <table>
                <tr>
                    <th>Device ID</th>
                    <th>Status</th>
                    <th>Packets Received</th>
                    <th>Rate Limit Status</th>
                    <th>Blocked Reason</th>
                    <th>Action</th>
                </tr>
                {% for device, authorized in devices.items() %}
                <tr>
                    <td>{{ device }}</td>
                    <td class="{{ 'authorized' if authorized else 'unauthorized' }}">
                        {{ 'Authorized' if authorized else 'Unauthorized' }}
                    </td>
                    <td id="packets-{{ device }}">{{ data[device] }}</td>
                    <td id="rate-limit-{{ device }}">0/60</td>
                    <td id="blocked-reason-{{ device }}">-</td>
                    <td>
                        <form method="POST" action="/update">
                            <input type="hidden" name="device_id" value="{{ device }}">
                            <button type="submit" name="action" value="{{ 'revoke' if authorized else 'authorize' }}">
                                {{ 'Revoke' if authorized else 'Authorize' }}
                            </button>
                        </form>
                    </td>
                </tr>
                {% endfor %}
            </table>
        </div>

        <div class="section packet-counter">
            Total Packets Received: <span id="total-packets">0</span>
        </div>

        <div class="section">
            <h2>Network Topology</h2>
            <div class="legend">
                <span style="background-color: #90ee90;"></span> Online
                <span style="background-color: #ffcccb; margin-left: 20px;"></span> Offline
            </div>
            <div id="network"></div>
        </div>

        <div class="section graph-container">
            <h2>Packets Received Over Time</h2>
            <img src="/graph" id="graph" onload="setTimeout(() => this.src='/graph?'+Date.now(), 5000)">
        </div>

        <div class="section">
            <h2>Device Health Metrics</h2>
            <div class="health-metrics" id="health-metrics"></div>
        </div>

        <div class="section">
            <h2>SDN Policy Controls</h2>
            <div class="policy-controls">
                <div class="policy-card">
                    <h3>Packet Inspection</h3>
                    <form method="POST" action="/update_policy">
                        <input type="hidden" name="policy" value="packet_inspection">
                        <button type="submit" name="action" value="enable">Enable</button>
                        <button type="submit" name="action" value="disable">Disable</button>
                    </form>
                </div>
                <div class="policy-card">
                    <h3>Traffic Shaping</h3>
                    <form method="POST" action="/update_policy">
                        <input type="hidden" name="policy" value="traffic_shaping">
                        <button type="submit" name="action" value="enable">Enable</button>
                        <button type="submit" name="action" value="disable">Disable</button>
                    </form>
                </div>
                <div class="policy-card">
                    <h3>Dynamic Routing</h3>
                    <form method="POST" action="/update_policy">
                        <input type="hidden" name="policy" value="dynamic_routing">
                        <button type="submit" name="action" value="enable">Enable</button>
                        <button type="submit" name="action" value="disable">Disable</button>
                    </form>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>Policy Enforcement Logs</h2>
            <div class="policy-logs" id="policy-logs"></div>
        </div>

        <div class="section">
            <h2>SDN Metrics</h2>
            <div class="sdn-metrics" id="sdn-metrics"></div>
        </div>

        <!-- ML Security Engine Section -->
        <div class="section ml-section">
            <h2>ðŸ¤– ML Security Engine - DDoS Attack Detection</h2>
            <div style="margin-bottom: 20px;">
                <button onclick="initializeML()" style="background: linear-gradient(45deg, #00d4ff, #007bff); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; margin-right: 10px;">
                    Initialize ML Engine
                </button>
                <button onclick="toggleMLMonitoring()" style="background: linear-gradient(45deg, #28a745, #20c997); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">
                    Toggle Monitoring
                </button>
            </div>
            
            <div id="ml-status" style="margin-bottom: 20px;">
                <p>ML Engine Status: <span id="ml-status-text">Not Initialized</span></p>
            </div>
            
            <div id="ml-metrics" style="display: flex; flex-wrap: wrap; justify-content: center;">
                <!-- ML metrics will be populated here -->
            </div>
            
            <div style="margin-top: 20px;">
                <h3>Recent Attack Detections</h3>
                <div id="ml-detections" style="max-height: 200px; overflow-y: auto; background: rgba(0, 0, 0, 0.3); padding: 10px; border-radius: 5px;">
                    <!-- Attack detections will be populated here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        let totalPackets = 0;

        function updatePacketCounts() {
            fetch('/get_data')
                .then(response => response.json())
                .then(data => {
                    let newTotal = 0;
                    for (const device in data) {
                        const packetsEl = document.getElementById(`packets-${device}`);
                        const rateLimitEl = document.getElementById(`rate-limit-${device}`);
                        const blockedReasonEl = document.getElementById(`blocked-reason-${device}`);
                        if (packetsEl) packetsEl.textContent = data[device].packets;
                        if (rateLimitEl) rateLimitEl.textContent = data[device].rate_limit_status;
                        if (blockedReasonEl) blockedReasonEl.textContent = data[device].blocked_reason || '-';
                        newTotal += data[device].packets;
                    }
                    animatePacketCounter(newTotal);
                })
                .catch(error => console.error('Error fetching data:', error));
        }

        function animatePacketCounter(newTotal) {
            const counter = document.getElementById('total-packets');
            const start = totalPackets;
            const end = newTotal;
            const duration = 1000;
            let startTime = null;

            function step(timestamp) {
                if (!startTime) startTime = timestamp;
                const progress = Math.min((timestamp - startTime) / duration, 1);
                const current = Math.floor(start + (end - start) * progress);
                counter.textContent = current;
                if (progress < 1) {
                    requestAnimationFrame(step);
                } else {
                    totalPackets = end;
                }
            }
            requestAnimationFrame(step);
        }

        function updateTopology() {
            fetch('/get_topology_with_mac')
                .then(response => response.json())
                .then(data => {
                    const nodes = new vis.DataSet(data.nodes.map(node => ({
                        id: node.id,
                        label: `${node.label}\n${node.mac}\n${node.online ? 'Online' : 'Offline'}`,
                        title: `Last Seen: ${new Date(node.last_seen * 1000).toLocaleTimeString()}\nPackets: ${node.packets}`,
                        color: node.online ? '#90ee90' : '#ffcccb',
                        font: { multi: true, size: 12 }
                    })));
                    
                    const edges = new vis.DataSet(data.edges.map(edge => ({
                        from: edge.from,
                        to: edge.to,
                        color: { color: '#848484' },
                        dashes: true,
                        arrows: 'to'
                    })));
                    
                    const container = document.getElementById('network');
                    const networkData = { nodes: nodes, edges: edges };
                    const options = {
                        nodes: {
                            shape: 'dot',
                            size: 30,
                            font: { size: 12, multi: true, align: 'center' }
                        },
                        edges: {
                            width: 2
                        },
                        physics: {
                            enabled: true,
                            stabilization: true,
                            barnesHut: {
                                gravitationalConstant: -3000,
                                springLength: 150
                            }
                        }
                    };
                    const network = new vis.Network(container, networkData, options);
                })
                .catch(error => console.error('Error fetching topology:', error));
        }

        function updateHealthMetrics() {
            fetch('/get_health_metrics')
                .then(response => response.json())
                .then(data => {
                    const container = document.getElementById('health-metrics');
                    container.innerHTML = '';
                    for (const device in data) {
                        const metrics = data[device];
                        const card = document.createElement('div');
                        card.className = 'metric-card';
                        card.innerHTML = `
                            <h3>${device}</h3>
                            <p>CPU Usage: ${metrics.cpu_usage}%</p>
                            <div class="metric-bar"><div style="width: ${metrics.cpu_usage}%"></div></div>
                            <p>Memory Usage: ${metrics.memory_usage}%</p>
                            <div class="metric-bar"><div style="width: ${metrics.memory_usage}%"></div></div>
                            <p>Uptime: ${metrics.uptime} seconds</p>
                        `;
                        container.appendChild(card);
                    }
                })
                .catch(error => console.error('Error fetching health metrics:', error));
        }

        function updatePolicyLogs() {
            fetch('/get_policy_logs')
                .then(response => response.json())
                .then(logs => {
                    const container = document.getElementById('policy-logs');
                    container.innerHTML = '';
                    logs.forEach(log => {
                        const p = document.createElement('p');
                        p.textContent = log;
                        container.appendChild(p);
                    });
                    container.scrollTop = container.scrollHeight;  // Auto-scroll to bottom
                })
                .catch(error => console.error('Error fetching policy logs:', error));
        }

        function updateSDNMetrics() {
            fetch('/get_sdn_metrics')
                .then(response => response.json())
                .then(data => {
                    const container = document.getElementById('sdn-metrics');
                    container.innerHTML = '';
                    for (const [metric, value] of Object.entries(data)) {
                        const card = document.createElement('div');
                        card.className = 'sdn-metric';
                        const metricName = metric.replace('_', ' ').replace(/\b\w/g, c => c.toUpperCase());
                        card.innerHTML = `
                            <h3>${metricName}</h3>
                            <p>${value} ${metric.includes('latency') ? 'ms' : metric.includes('throughput') ? 'Mbps' : '%'}</p>
                        `;
                        container.appendChild(card);
                    }
                })
                .catch(error => console.error('Error fetching SDN metrics:', error));
        }

        // ML Security Engine Functions
        let mlEngineActive = false;
        
        function initializeML() {
            fetch('/ml/initialize')
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        document.getElementById('ml-status-text').textContent = 'Active';
                        document.getElementById('ml-status-text').style.color = '#00ff00';
                        mlEngineActive = true;
                        updateMLMetrics();
                        updateMLDetections();
                    } else {
                        alert('Failed to initialize ML engine: ' + data.message);
                    }
                })
                .catch(error => {
                    console.error('Error initializing ML:', error);
                    alert('Error initializing ML engine');
                });
        }
        
        function toggleMLMonitoring() {
            if (mlEngineActive) {
                mlEngineActive = false;
                document.getElementById('ml-status-text').textContent = 'Monitoring Stopped';
                document.getElementById('ml-status-text').style.color = '#ffaa00';
            } else {
                mlEngineActive = true;
                document.getElementById('ml-status-text').textContent = 'Monitoring Active';
                document.getElementById('ml-status-text').style.color = '#00ff00';
            }
        }
        
        function updateMLMetrics() {
            if (!mlEngineActive) return;
            
            fetch('/ml/statistics')
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        console.error('ML statistics error:', data.error);
                        return;
                    }
                    
                    const container = document.getElementById('ml-metrics');
                    container.innerHTML = '';
                    
                    // Create metric cards
                    const metrics = [
                        { label: 'Total Packets', value: data.total_packets || 0 },
                        { label: 'Attack Packets', value: data.attack_packets || 0 },
                        { label: 'Normal Packets', value: data.normal_packets || 0 },
                        { label: 'Attack Rate', value: (data.attack_rate || 0).toFixed(2) + '%' },
                        { label: 'Detection Accuracy', value: (data.detection_accuracy || 0).toFixed(2) + '%' },
                        { label: 'Recent Attacks', value: data.recent_attacks || 0 }
                    ];
                    
                    metrics.forEach(metric => {
                        const card = document.createElement('div');
                        card.className = 'ml-metric';
                        card.innerHTML = `
                            <div class="ml-metric-value">${metric.value}</div>
                            <div class="ml-metric-label">${metric.label}</div>
                        `;
                        container.appendChild(card);
                    });
                })
                .catch(error => console.error('Error fetching ML metrics:', error));
        }
        
        function updateMLDetections() {
            if (!mlEngineActive) return;
            
            fetch('/ml/detections')
                .then(response => response.json())
                .then(detections => {
                    const container = document.getElementById('ml-detections');
                    container.innerHTML = '';
                    
                    if (detections.length === 0) {
                        container.innerHTML = '<p>No recent detections</p>';
                        return;
                    }
                    
                    detections.slice(-10).reverse().forEach(detection => {
                        const div = document.createElement('div');
                        div.style.marginBottom = '10px';
                        div.style.padding = '8px';
                        div.style.borderRadius = '5px';
                        div.style.background = detection.is_attack ? 
                            'linear-gradient(45deg, #ff6b6b, #ee5a24)' : 
                            'rgba(0, 255, 0, 0.2)';
                        div.style.border = detection.is_attack ? '2px solid #ff3838' : '1px solid #00ff00';
                        
                        const timestamp = new Date(detection.timestamp).toLocaleTimeString();
                        const confidence = (detection.confidence * 100).toFixed(2);
                        
                        div.innerHTML = `
                            <strong>${detection.attack_type}</strong> 
                            (${confidence}% confidence) - ${timestamp}
                            ${detection.is_attack ? ' ðŸš¨' : ' âœ…'}
                        `;
                        
                        container.appendChild(div);
                    });
                })
                .catch(error => console.error('Error fetching ML detections:', error));
        }

        setInterval(() => {
            updatePacketCounts();
            updateTopology();
            updateHealthMetrics();
            updatePolicyLogs();
            updateSDNMetrics();
            if (mlEngineActive) {
                updateMLMetrics();
                updateMLDetections();
            }
        }, 5000);

        updatePacketCounts();
        updateTopology();
        updateHealthMetrics();
        updatePolicyLogs();
        updateSDNMetrics();
    </script>
</body>
</html>